# C-- Compiler Front-End è½»é‡ç±»Cè¯­è¨€ç¼–è¯‘å™¨å‰ç«¯

## è¿è¡Œç¯å¢ƒ

1. **ç³»ç»Ÿä¸å†…æ ¸ç‰ˆæœ¬**ï¼šGNU Linux Release: Ubuntu 20.04, kernel version 5.13.0-44-genericï¼›
2. **ç¼–è¯‘å™¨**ï¼šGCC version 7.5.0ï¼›
3. **åˆ†æå™¨ç”Ÿæˆå·¥å…·**ï¼šGNU Flex version 2.6.4 ä»¥åŠ GNU Bison version 3.0.4

## æ–‡ä»¶ç»“æ„

```
.
â”œâ”€â”€ README.md
// ç¼–è¯‘ã€è°ƒè¯•æ–‡ä»¶
â”œâ”€â”€ Makefile
â”œâ”€â”€ init.gdb
â”œâ”€â”€ testcase
// stage 1 è¯æ³•è¯­æ³•åˆ†æï¼šæ„é€ è¯­æ³•æ ‘
â”œâ”€â”€ main.c
â”œâ”€â”€ mylexer.l
â”œâ”€â”€ myparser.y
â”œâ”€â”€ tree.c
â”œâ”€â”€ tree.h
â”œâ”€â”€ util.c
â””â”€â”€ util.h
// stage 2 è¯­ä¹‰åˆ†æï¼šè¯­æ³•æ£€æŸ¥å’Œç±»å‹æ£€æŸ¥
â”œâ”€â”€ cmm-L-SDT.txt
â”œâ”€â”€ cmm-S-SDT.txt
â”œâ”€â”€ semantic.c
â”œâ”€â”€ semantic.h
â”œâ”€â”€ sym-table.c
â”œâ”€â”€ sym-table.h
â”œâ”€â”€ type-system.c
â”œâ”€â”€ type-system.h
// stage 3 ä¸­é—´ä»£ç ç”Ÿæˆ
â”œâ”€â”€ cmm-IR-SDT.txt
â”œâ”€â”€ sdt.c
â”œâ”€â”€ sdt.h
â”œâ”€â”€ ir-gen.c
â”œâ”€â”€ ir-gen.h
â”œâ”€â”€ out1.ir
```


## åŠŸèƒ½å®ç°

### stage1 è¯æ³•ä¸è¯­æ³•åˆ†æ

å®ç°äº†è¯æ³•åˆ†æå’Œè¯­æ³•åˆ†æï¼Œåœ¨æ²¡æœ‰è¯æ³•æˆ–è¯­æ³•é”™è¯¯çš„æƒ…å†µä¸‹èƒ½å¤Ÿè¾“å‡ºè¯­æ³•æ ‘ã€‚

- **è¯æ³•å’Œè¯­æ³•å•å…ƒè¯†åˆ«**ï¼šåœ¨`mylexer.l`å’Œ`myparser.y`ä¸­åˆ†åˆ«ç¼–å†™è¯†åˆ«è§„åˆ™æ¥è¯†åˆ«è¯æ³•å•å…ƒå’Œè¯­æ³•å•å…ƒã€‚

- **è¯­æ³•æ ‘æ„é€ ä¸æ‰“å°**ï¼šè¯­æ³•æ ‘ä½¿ç”¨æœ´ç´ çš„å¤šå‰æ ‘ç»“æ„ï¼Œæ¥å£åœ¨`util.c`ä¸­å®ç°ï¼š

  ```c
  struct node {
      char*  str;				 // èŠ‚ç‚¹åç§°			
      int    lineno; 			 // å½“å‰è¯æ³•/è¯­æ³•å•å…ƒå‡ºç°çš„è¡Œå·
      size_t arr_len;     	 // å­èŠ‚ç‚¹æ•°é‡
      struct node* *child_arr; // ä½¿ç”¨åŠ¨æ€æŒ‡é’ˆæ•°ç»„ç®¡ç†å­èŠ‚ç‚¹
  };
  struct node* create_node(const char* ndname, const int lno);
  void         free_node(struct node *parent);					// é€’å½’é‡Šæ”¾èŠ‚ç‚¹å†…å­˜
  void         insert_node(struct node *parent, size_t n, ...);	// ä½¿ç”¨å˜é•¿å‚æ•°æ’å…¥å­èŠ‚ç‚¹
  void         print_tree(struct node *parent, int level); 		// é€’å½’æ‰“å°, levelä½œä¸ºèŠ‚ç‚¹ç¼©è¿›å‚è€ƒ
  struct node* create_syntax_node(const char *ndname, struct node *first_child); //create_nodeçš„ä¸Šå±‚å°è£…
  ```

  è¯æ³•/è¯­æ³•å•å…ƒæ•°å€¼`yylval`ç±»å‹ç»Ÿä¸€ä¸º`struct node *`ï¼Œä½¿ç”¨`%union`å’Œ`%token`ã€`%type`æ¥å®šä¹‰ï¼š

  ```yyac
  %union {
      struct node * nd;
  }
  %token <nd> INT
  ...
  %type <nd> Program
  ...
  ```

  åˆ›å»ºèŠ‚ç‚¹æ“ä½œåˆ†åˆ«åœ¨.lå’Œ.yæ–‡ä»¶ä¸­å®ç°ï¼Œç¤ºä¾‹å¦‚ä¸‹ï¼Œ`Program`ä½œä¸ºå¼€å§‹ç¬¦å·éœ€è¦**æ‰“å°è¯­æ³•æ ‘**ï¼š

  ```flex bison
  // mylexer.l (å¶å­èŠ‚ç‚¹)
  ";"         {yylval.nd = create_node("SEMI", yylineno); return (SEMI);}
  // myparser.y 
  %start Program
  %%
  Program : 	 ExtDefList  {$$ = create_syntax_node("Program", $1); 
  					insert_node($$, 1, $1); if(!err_occur) print_tree($$, 0);};
  ```

- **é”™è¯¯æ¢å¤**ï¼š

  - è¯æ³•é”™è¯¯è¾“å‡ºå‡½æ•°`lex_error_hanlde`ï¼Œè¯­æ³•é”™è¯¯è¾“å‡ºä¿®æ”¹äº†å‡½æ•°`yyerror`ï¼Œé€šè¿‡ä¿®æ”¹`util.h`ä¸­çš„å®`ERR_OUT_FD`æ¥é‡å®šå‘é”™è¯¯è¾“å‡ºï¼›
  - å¯¹äº**æŒ‡æ•°å½¢å¼çš„æµ®ç‚¹æ•°**ä»¥åŠæ™®é€šè¯æ³•é”™è¯¯ï¼Œä¼šç›´æ¥è°ƒç”¨`lex_error_handle`æŠ¥å‡ºè¯æ³•é”™è¯¯ï¼Œå¹¶è®¾ç½®`err_occur=1`å’Œ`lex_error=1`ï¼Œé¿å…è¯­æ³•æ ‘å’Œè¯­æ³•é”™è¯¯è¾“å‡ºã€‚
  - å¯¹äº**æ³¨é‡Šå†…å®¹**ï¼Œåœ¨`mylexer.l`ä½¿ç”¨`%x`åŠŸèƒ½ï¼ˆå‚è€ƒ[Flex: Start Conditions](https://www.cs.virginia.edu/~cr4bd/flex-manual/Start-Conditions.html)ï¼‰**å¿½ç•¥**æ³¨é‡Šå†…éƒ¨å†…å®¹é¿å…é‡å¤æŠ¥é”™ï¼ˆè¯¦ç»†è§ä»£ç ï¼‰ï¼Œè®¾ç½®`cmt_error=1`å¹¶ä½¿ç”¨`yyerror`è¾“å‡ºè¯­æ³•é”™è¯¯ï¼›
  - å¯¹äº**æ™®é€šè¯­æ³•é”™è¯¯**ï¼Œåœ¨æ–‡æ³•ä¸­æ·»åŠ **error token**å¢åŠ äº§ç”Ÿå¼æ¥è¿›è¡Œè¯†åˆ«ï¼Œä¸»è¦é›†ä¸­åœ¨æ‹¬å·é…å¯¹éƒ¨åˆ†ï¼Œå…¶ä½™åªéœ€åœ¨éƒ¨åˆ†åº•éƒ¨è¯­æ³•å•å…ƒæ·»åŠ å³å¯ï¼ˆé”™è¯¯æ˜¯è‡ªåº•å‘ä¸Šäº§ç”Ÿçš„ï¼‰ï¼›è¯†åˆ«åè‡ªåŠ¨ä½¿ç”¨`yyerror`æ¥è¾“å‡ºè¯­æ³•é”™è¯¯ã€‚è¯¦ç»†æ¢å¤è¿‡ç¨‹é˜…è¯»äº†æ–‡æ¡£ï¼š[Error Recovery (Bison 3.8.1)](https://www.gnu.org/software/bison/manual/html_node/Error-Recovery.html)

- **å†…å­˜ç®¡ç†**ï¼šåœ¨`myparser.y`ä¸­ä½¿ç”¨`%destructor`åŠŸèƒ½æ¥é‡Šæ”¾**å¼ƒç”¨èŠ‚ç‚¹**ï¼ˆè¢«discardæˆ–cleanupçš„è¯æ³•/è¯­æ³•å•å…ƒï¼‰æ‰€æŒæœ‰çš„åŠ¨æ€å†…å­˜ï¼Œå¯é…åˆ`leak-sanitizer`è¿›è¡Œå†…å­˜æ³„æ¼æ£€æŸ¥ï¼ˆè§Makefile)ï¼š

  ```yyac
  %destructor { free_node($$);} <nd>
  ```

  bisonè¿›è¡Œdestructçš„è¿‡ç¨‹å‚è€ƒbisonå®˜æ–¹æ–‡æ¡£ï¼š[Destructor Decl (Bison 3.8.1)](https://www.gnu.org/software/bison/manual/html_node/Destructor-Decl.html) 

------

### stage2 è¯­ä¹‰åˆ†æ

å®ç°è¯­ä¹‰åˆ†æã€‚è¿‡ç¨‹åŒ…æ‹¬æ„é€ ç±»å‹ç³»ç»Ÿï¼Œç¼–å†™Lå±æ€§SDTï¼Œé€’å½’å‘ä¸‹è¯­ä¹‰åˆ†æï¼Œç¬¦å·è¡¨ç®¡ç†ï¼Œä»¥åŠé™æ€ç±»å‹æ£€æŸ¥ã€‚

#### 2.1 Type System

å…ˆæ„é€ å¥½ç±»å‹ç³»ç»Ÿæ¥æè¿°**ç¬¦å·ç±»å‹**ç»„æˆï¼š

- `Type System`ä¸­çš„`component`åˆ†ä¸º`[T]`ã€`[F]`ã€`[E]`ã€`T`ã€`F`ã€`S`ä»¥åŠ`S List`(å³SL)ã€‚

- ä»£ç ä¸­ä½¿ç”¨ä¸‰ç§structæ¥åˆ†åˆ«æ„æˆ`[T]`ã€`[F]`å’Œ`[E]`è¿™ä¸‰ä¸ªåŸºæœ¬å•ä½ï¼šstruct Type ã€struct Field ä»¥åŠstruct Exptypeï¼Œåé¢çš„componentä¾èµ–è¿™äº›åŸºæœ¬å•ä½æ¥æ„é€ å¾—åˆ°ã€‚

  ```c
  // type-system.h
  enum Tenum { B_INT, B_FLOAT, ARRAY, STRUCTURE_VAR, STRUCTURE_DEF, FUNC };
  
  struct Field {
      char*         name; // ç¬¦å·åç§°
      struct Type  *type; // æŒ‡å‘ä¿¡æ¯å°¾éƒ¨
      struct Field *next; // ä¸‹ä¸€ä¸ªä¿¡æ¯å¤´éƒ¨
  };
  
  struct Type {
      enum Tenum kind;
      union {
  		// ... see the file
      } u;
  };
  
  struct Exptype {
      enum Tenum kind;                // è¡¨è¾¾å¼ç±»å‹
      enum {LVAL, RVAL} lrval_flag;   // å·¦å³å€¼ç±»å‹
      struct Type *t_ptr;             // Type æŒ‡é’ˆï¼Œå½“è¡¨è¾¾å¼ä¸ºç‰¹å®šç±»å‹(structã€func)æ—¶å¯ç”¨
  };
  ```

- æ¯ä¸€ä¸ªéœ€è¦åŠ å…¥ç¬¦å·è¡¨ä¸­çš„ç¬¦å·ï¼Œå…¶æŒ‡å‘çš„**ç±»å‹ä¿¡æ¯**ä¸ºä¸€ä¸ª`S`ã€‚ï¼ˆè§`sym-table.h`ä¸­ç¬¦å·çš„structç»“æ„ï¼‰

- `T`ï¼Œä¿¡æ¯å°¾éƒ¨ï¼Œè¯­ä¹‰ä¸Šä»£è¡¨åŸºæœ¬å˜é‡ç±»å‹æˆ–ç»“æ„å˜é‡ç±»å‹ï¼š

  ```
  KIND  		  COMPOSITION				FUNC
  T_basic:      [T(B_INT)] or [T(B_FLOAT)]              --- make_T_basic(TYPE)
  T_struct_var: [T(STRUCTURE_VAR)] -> S_struct_def      --- make_T_struct(S_struct_def)
  ```

- `F`ï¼Œä¿¡æ¯å¤´éƒ¨ï¼Œå››ç§ç±»å‹ä»¥åŠå¯¹åº”æ„é€ æ–¹å¼ï¼š

  ```
  F_basic:      [F]->null(T)                            --- make_F_basic(id)  
  F_array:      [F]->[T(ARRAY)]->......->null(T)        --- make_F_array(F_basic or F_arr) 
  F_struct_def: [F]->[T(STRUCTURE_DEF)]->null(SL)       --- make_F_struct(id)
  F_func:       [F]->[T(FUNC)]-+--->null(T)             --- make_F_func(id)
                               `-->null(SL)
  ```

- `S`ï¼Œç±»å‹ä¿¡æ¯æ•´ä½“ï¼Œç”±ä¸åŒçš„å¤´éƒ¨Få’Œå°¾éƒ¨Tè¿æ¥å¾—åˆ°ï¼Œæœ‰å››ç§ç±»å‹ä»¥åŠå¯¹åº”æ„é€ æ–¹å¼ï¼š

  ```
  S_single:     F_basic->(T_basic or T_struct_var)      --- make_S_single(F_basic, T)
  S_array:      F_array->(T_basic or T_struct_var)      --- make_S_array(F_array, T)
  S_struct_def: F_struct_def-> SL                       --- make_S_struct(F_struct_def, SL)
  S_func:       F_func-+-->(T_basic or T_struct_var)    --- make_S_func(T, F_func, SL)
                       `--> SL
  ```

- `SL`ï¼šç±»å‹ä¿¡æ¯é“¾è¡¨ï¼Œç”±å¤šä¸ª`S`é€šè¿‡`[F].next`è¿æ¥å¾—åˆ°ã€‚

#### 2.2 Lå±æ€§SDT

ç¼–å†™SDTçš„è¿‡ç¨‹æ¯”è¾ƒéº»çƒ¦ï¼Œå°¤å…¶æ˜¯Lå±æ€§çš„SDTã€‚åœ¨æ„å»ºå¥½ç±»å‹ç³»ç»Ÿåï¼ŒæŒ‰ç…§ç±»å‹ç³»ç»Ÿåˆ†åˆ«å¼„æ¸…æ¥šæ¯ä¸ªéç»ˆç»“ç¬¦éœ€è¦ä»€ä¹ˆæ ·çš„ç»§æ‰¿å±æ€§å’Œç»¼åˆå±æ€§ï¼Œå±æ€§ä¼ é€’è¿‡ç¨‹æ˜¯æ€æ ·çš„ï¼Œæ¯ä¸ªéç»ˆç»“ç¬¦éƒ½åº”è¯¥ç”»ä¸€æ£µè¯­æ³•åˆ†ææ ‘ï¼Œå»çœ‹çœ‹ç±»å‹çš„æ„é€ æ˜¯ä¸€ä¸ªä»€ä¹ˆæ ·çš„è¿‡ç¨‹ã€‚

åœ¨æ„é€ çš„SDTä¸­ï¼Œæ¯ä¸ªéç»ˆç»“ç¬¦æ‹¥æœ‰çš„å±æ€§å‡ä½¿ç”¨ä»¥ä¸‹è¡¨è¾¾å½¢å¼ï¼š

```
(XXX):Y		XXXä¸ºcomponentç±»å‹(T,F,S,SL), Yä¸ºå±æ€§åç§°,å¸¸è§æœ‰tå’Œb,ä¸€èˆ¬ä»¥tä¸ºç»¼åˆå±æ€§,bä¸ºç»§æ‰¿å±æ€§
```

è¯¦ç»†SDTè§æ–‡ä»¶`cmm-L-SDT.txt`ã€‚

#### 2.3 é€’å½’å‘ä¸‹è¯­æ³•åˆ†æ

é€’å½’å‘ä¸‹æ³•ä½¿ç”¨äº†å’ŒDFSè¿‘ä¼¼çš„ç®—æ³•ï¼Œåœ¨**å·²ç»æ„å»ºå¥½çš„è¯­æ³•æ ‘**ä¸Šè¿›è¡Œä»ä¸‹å¾€ä¸Šã€ä»å·¦å¾€å³çš„åˆ†æï¼Œç”±äºæ¯ä¸ªéç»ˆç»“ç¬¦æœ‰ç€ä¸åŒçš„è¯­ä¹‰åŠ¨ä½œï¼Œæ‰€ä»¥éœ€è¦æ ¹æ®SDTï¼Œä¸ºæ¯ä¸€ä¸ªéç»ˆç»“ç¬¦éƒ½æ„é€ ä¸€ä¸ªåˆ†æå‡½æ•°ï¼š

```c
// sdt.h
void           sem_Program       (struct node *root); 
void           sem_ExtDefList    (struct node *root); 
void           sem_ExtDef        (struct node *root);
struct Field * sem_ExtDecList    (struct node *root, struct Type *inh_val); // inh_valä¼ é€’ç»§æ‰¿å±æ€§
// ...
```

#### 2.4 ç¬¦å·è¡¨ç®¡ç†

åœ¨é€’å½’å‘ä¸‹åˆ†æçš„è¿‡ç¨‹ä¸­ï¼Œå¦‚`ExtDef`, `Dec`ç­‰éç»ˆç»“ç¬¦ä¼šæ„é€ å‡ºå®Œæ•´çš„ç±»å‹ä¿¡æ¯`S`ï¼Œå¹¶å°†å…¶æ·»åŠ åˆ°ç¬¦å·è¡¨ä¸­ã€‚

ç¬¦å·è¡¨å±‚æ¬¡ç»“æ„ä¸º"è¡¨å¤´--è¡¨èŠ‚ç‚¹--ç¬¦å·--Så€¼ä¸[E]å€¼"ï¼Œåˆ†å››ä¸ªå±‚æ¬¡å‘ä¸‹ï¼›

ç”±äºéœ€è¦å®Œæˆstage2ä¸­çš„è¦æ±‚2.2ï¼Œâ€œ**æ”¯æŒå˜é‡åœ¨å¤šå±‚ä½œç”¨åŸŸå®šä¹‰**â€ï¼Œæ‰€ä»¥ç¬¦å·è¡¨é‡‡ç”¨çš„æ˜¯**Imperative Style**çš„å½¢å¼ï¼Œæ¯ä¸€ä¸ªç¬¦å·èŠ‚ç‚¹ä½¿ç”¨"**åå­—é“¾è¡¨+open hashingæ•£åˆ—è¡¨**" çš„å½¢å¼æ¥ç»„ç»‡ï¼Œè§ä»£ç æ³¨é‡Šï¼š

```c
// sym-table.h
struct header *symbol_table; // ç¬¦å·è¡¨å¤´éƒ¨æ•°ç»„(åŠ¨æ€)ï¼Œæ¯ä¸€ä¸ªå¤´éƒ¨æŒ‡å‘ä¸€ä¸ªèŠ‚ç‚¹ç»„æˆçš„é“¾è¡¨slotï¼Œslotç”¨æ¥è§„é¿å“ˆå¸Œå†²çªï¼ˆå³é“¾åœ°å€æ³•ï¼‰
struct header *scope_stack;	 // ä½œç”¨åŸŸå¤´éƒ¨æ ˆ(åŠ¨æ€)ï¼Œä¸åŒå¤´éƒ¨æŒ‡å‘ä¸åŒçš„"ä½œç”¨åŸŸç¬¦å·èŠ‚ç‚¹é“¾è¡¨",ä½¿ç”¨å˜é‡stk_topæ¥æŒ‡å‘æ ˆé¡¶

// ç¬¦å·
struct symbol {
    struct Field *sym_field; //  S  in the type system.
    struct Exptype *sym_val; // [E] in the type system.
};

// ç¬¦å·è¡¨èŠ‚ç‚¹
struct symbol_node {
    int hval,sval,lineno;			// èŠ‚ç‚¹å“ˆå¸Œå€¼,èŠ‚ç‚¹æ‰€å¤„ä½œç”¨åŸŸ,ç¬¦å·å‡ºç°è¡Œæ•°
    struct symbol_node *slot_next;  // æŒ‡å‘åŒä¸€ä¸ªslotçš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
    struct symbol_node *scope_next; // æŒ‡å‘åŒä¸€ä¸ªscopeçš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
    struct symbol 		sym;        // æŒ‡å‘ç¬¦å· 
};

// ç¬¦å·è¡¨/ä½œç”¨åŸŸæ ˆ çš„æ•°ç»„å…ƒç´ ï¼Œä»£è¡¨slotå¤´æˆ–scopeå¤´
struct header {
    union {
        struct symbol_node *slot_ptr;   
        struct symbol_node *scope_ptr;
    };
};
```

> **Imperative Style ç»´æŠ¤é£æ ¼**ï¼šå®ƒä¸ä¼šç”³è¯·å¤šä¸ªç¬¦å·è¡¨ï¼Œè€Œæ˜¯è‡ªå§‹è‡³ç»ˆåœ¨å•ä¸ªç¬¦å·è¡¨ä¸Šè¿›è¡ŒåŠ¨æ€ç»´æŠ¤ã€‚å‡è®¾ç¼–è¯‘å™¨åœ¨å¤„ç†åˆ°å½“å‰å‡½æ•°fæ—¶ç¬¦å·è¡¨é‡Œæœ‰aã€bã€cè¿™ä¸‰ä¸ªå˜é‡çš„å®šä¹‰ã€‚å½“ç¼–è¯‘å™¨å‘ç°å‡½æ•°ä¸­å‡ºç°äº†ä¸€ä¸ªè¢«â€œ{â€å’Œâ€œ}â€åŒ…å«çš„è¯­å¥å—ï¼Œè€Œåœ¨è¿™ä¸ªè¯­å¥å—ä¸­åˆæœ‰æ–°çš„å˜é‡å®šä¹‰æ—¶ï¼Œå®ƒä¼šå°†è¯¥å˜é‡æ’å…¥fçš„ç¬¦å·è¡¨é‡Œã€‚å½“è¯­å¥å—ä¸­å‡ºç°ä»»ä½•è¡¨è¾¾å¼ä½¿ç”¨æŸä¸ªå˜é‡æ—¶ï¼Œç¼–è¯‘å™¨å°±æŸ¥æ‰¾fçš„ç¬¦å·è¡¨ã€‚å¦‚æœæŸ¥æ‰¾å¤±è´¥ï¼Œåˆ™æŠ¥å‘Šä¸€ä¸ªå˜é‡æœªå®šä¹‰çš„é”™è¯¯ï¼›å¦‚æœæŸ¥è¡¨æˆåŠŸï¼Œåˆ™è¿”å›æŸ¥åˆ°çš„å˜é‡å®šä¹‰ï¼›å¦‚æœå‡ºç°äº†å˜é‡æ—¢åœ¨å¤–å±‚åˆåœ¨å†…å±‚è¢«å®šä¹‰çš„æƒ…å†µï¼Œåˆ™è¦æ±‚ç¬¦å·è¡¨è¿”å›æœ€è¿‘çš„é‚£ä¸ªå®šä¹‰ã€‚æ¯å½“ç¼–è¯‘å™¨ç¦»å¼€æŸä¸ªè¯­å¥å—æ—¶ï¼Œä¼šå°†è¿™ä¸ªè¯­å¥å—ä¸­å®šä¹‰çš„å˜é‡å…¨éƒ¨ä»è¡¨ä¸­åˆ é™¤ã€‚

> **åŸºäºåå­—é“¾è¡¨å’Œopen hashingæ•£åˆ—è¡¨**ï¼šè¿™ç§è®¾è®¡çš„åˆè¡·å¾ˆç®€å•ï¼Œé™¤äº†æ•£åˆ—è¡¨æœ¬èº«ä¸ºäº†è§£å†³å†²çªé—®é¢˜æ‰€å¼•å…¥çš„sloté“¾è¡¨ä¹‹å¤–ï¼Œå®ƒä»å¦ä¸€ç»´åº¦ä¹Ÿå¼•å…¥scopeé“¾è¡¨å°†ç¬¦å·è¡¨ä¸­å±äºåŒä¸€å±‚ä½œç”¨åŸŸçš„æ‰€æœ‰å˜é‡éƒ½ä¸²èµ·æ¥ã€‚

ä»¥ä¸‹æ˜¯`sym-table.c`ä¸­å‡½æ•°å¯¹Imperative Styleçš„å‡½æ•°å®ç°ï¼š

- `add_symbol`: æ¯æ¬¡å‘æ•£åˆ—è¡¨ä¸­æ’å…¥å…ƒç´ æ—¶ï¼Œæ€»æ˜¯å°†æ–°æ’å…¥çš„å…ƒç´ æ”¾åˆ°è¯¥slotä¸‹æŒ‚çš„é“¾è¡¨ä»¥åŠè¯¥å±‚æ‰€å¯¹åº”çš„é“¾è¡¨çš„è¡¨å¤´ã€‚
- `search_symbol`: æ¯æ¬¡æŸ¥è¡¨æ—¶å¦‚æœå®šä½åˆ°æŸä¸ªslotï¼Œåˆ™æŒ‰é¡ºåºéå†è¿™ä¸ªslotä¸‹æŒ‚çš„é“¾è¡¨å¹¶è¿”å›è¿™ä¸ªslotä¸­ç¬¦åˆæ¡ä»¶çš„ç¬¬ä¸€ä¸ªå˜é‡ã€‚å¦‚æ­¤ä¸€æ¥ä¾¿å¯ä»¥ä¿è¯ï¼šå¦‚æœå‡ºç°äº†å˜é‡æ—¢åœ¨å¤–å±‚åˆåœ¨å†…å±‚è¢«å®šä¹‰çš„æƒ…å†µï¼Œç¬¦å·è¡¨èƒ½å¤Ÿè¿”å›ç›¸å¯¹è¯¥å˜é‡æœ€å†…å±‚çš„é‚£ä¸ªå®šä¹‰ã€‚
- `enter_scope`: æ¯æ¬¡è¿›å…¥ä¸€ä¸ªè¯­å¥å—ï¼Œéœ€è¦ä¸ºè¿™ä¸€å±‚è¯­å¥å—æ–°å»ºä¸€ä¸ªscopeé“¾è¡¨ç”¨æ¥ä¸²è”è¯¥å±‚ä¸­æ–°å®šä¹‰çš„å˜é‡ï¼›
- `exit_scope`: æ¯æ¬¡ç¦»å¼€ä¸€ä¸ªè¯­å¥å—ï¼Œåˆ™éœ€è¦é¡ºç€ä»£è¡¨è¯¥å±‚è¯­å¥å—çš„scopeé“¾è¡¨å°†æ‰€æœ‰æœ¬å±‚å®šä¹‰å˜é‡å…¨éƒ¨åˆ é™¤ã€‚

#### 2.5 é”™è¯¯æ£€æŸ¥

stage2ä¸­è¿›è¡Œçš„é”™è¯¯æ£€æŸ¥ä¸»è¦ä¸ºé™æ€ç±»å‹æ£€æŸ¥ã€‚

- å˜é‡å®šä¹‰æ£€æŸ¥ï¼šç”±`sym-table.c`æ¥å®Œæˆæ£€æŸ¥ç¬¦å·æœªå®šä¹‰ã€é‡å®šä¹‰ç­‰é”™è¯¯æ£€æŸ¥å·¥ä½œï¼›

- è¡¨è¾¾å¼ç±»å‹æ£€æŸ¥ï¼šé€šè¿‡å¯¹æ¯”ä¸¤ä¸ª**Tenum**å€¼ä»¥åŠæŒ‡å‘å¯¹åº”ç±»å‹ä¿¡æ¯å°¾éƒ¨**T**çš„ptræŒ‡é’ˆæ¥å®ç°ï¼Œå‡½æ•°å®ç°è§`sdt.c:compare_exptype`ï¼›
- å˜é‡è®¿é—®æ£€æŸ¥ï¼šæŸ¥çœ‹ç›¸åº”çš„**Tenum**å€¼ä»¥åŠæŒ‡å‘å¯¹åº”ç±»å‹ä¿¡æ¯å°¾éƒ¨**T**çš„ptræŒ‡é’ˆæ˜¯å¦ç¬¦åˆæ¡ä»¶ã€‚

æ¯ä¸€æ®µé”™è¯¯æ£€æŸ¥ä»£ç ç”±æ³¨é‡ŠåŒ…å›´ï¼Œä¾‹å­å¦‚ä¸‹ï¼š

```c
struct Exptype * sem_Exp(struct node *root) {
// ...
// Error 10: Exp should be array type.
if(e1->kind != ARRAY) {
    err_occur_sem(10, root->lineno, "Not an array", "^^");
    free(e1); e1 = NULL;
    return NULL;
} assert(e1->kind == ARRAY);
// Error 10: end.
//...
```

#### 2.6 æ³¨æ„äº‹é¡¹

> å¯¹äºç»“æ„ä½“ç±»å‹ç­‰ä»·çš„åˆ¤å®šï¼Œæ¯ä¸ªåŒ¿åçš„ç»“æ„ä½“ç±»å‹æˆ‘ä»¬è®¤ä¸ºå‡å…·æœ‰ä¸€ä¸ªç‹¬æœ‰çš„éšè—åå­—ï¼Œä»¥æ­¤è¿›è¡Œåç­‰ä»·åˆ¤å®šã€‚

åŒ¿åstructåˆ›å»ºæ—¶ï¼Œæ ¹æ®æ–‡æ³•ï¼Œå…¶OptTagä¸ºnullï¼Œè¿™é‡Œä½¿ç”¨å…¨å±€å˜é‡`anony_num`è´Ÿè´£è®°å½•åŒ¿åstructæ•°é‡ï¼Œåœ¨å‡½æ•° `semantic.c:sem_OptTag()` ä¸­å®ç°å¦‚ä¸‹ï¼š

```C
struct Field * sem_OptTag         (struct node *root) {
	...
    /* OptTag -> null    {create a anonymous struct name.}	*/ 
    if(root == NULL) {
        fname = (char *)malloc(10);
        sprintf(fname, "anony_%d", anony_num++);
    } 
	...
}
```

------

### stage3

å®ç°ä¸­é—´ä»£ç ç”Ÿæˆã€‚è¿‡ç¨‹åŒ…æ‹¬ï¼Œæ„é€ ä¸­é—´ä»£ç è¡¨ç¤ºï¼Œè‡ªè¡Œå®Œå–„IRç”ŸæˆSDTã€‚æ€»ä½“ä¸Šé‡‡ç”¨ç¬¨åŠæ³•ï¼šéå†åœ¨stage1ä¸­ç”Ÿæˆå¥½çš„è¯­æ³•æ ‘ã€‚

#### 3.1 ä¸­é—´ä»£ç è¡¨ç¤ºï¼šçº¿æ€§IRå®ç°

é¦–å…ˆæ˜¯å•æ¡ä¸­é—´ä»£ç çš„æ•°æ®ç»“æ„ï¼Œä½¿ç”¨ç±»ä¼¼ä¸‰åœ°å€ä»£ç çš„æ ¼å¼ï¼Œä¸€ä¸ªä¸­é—´ä»£ç structå¯¹è±¡ï¼ˆIC, InterCodeï¼‰ç”± `enum OperatorKind` **ä»£è¡¨çš„æ“ä½œç¬¦** å’Œ ç”± `union u` **å­˜å‚¨çš„æ“ä½œæ•°å¯¹è±¡** ç»„æˆã€‚ä¸­é—´ä»£ç å¯¹è±¡ç”±ä¸€ç³»åˆ—å‡½æ•° `ir-gen.c:Construct_XXXCode()` æ„é€ ã€‚

```c
struct InterCode {
    enum OperatorKind {  
            OP_ADD,   OP_SUB,   OP_MUL,     OP_DIV,
			...
        } kind;
    union {
        struct Operand *dec_func;
        struct {struct Operand *result, *op1, *op2; } binop;
        ...
    } u;
};
```

æ¯ä¸ªæ“ä½œæ•°éƒ½æ˜¯ä¸€ä¸ªstructå¯¹è±¡ï¼Œæœ‰è‡ªå·±çš„ `enum kind` å’Œ ç”±`union u`å­˜å‚¨çš„æ•°æ®ï¼Œå¹¶ä¸”åœ¨éœ€è¦è¿›è¡Œè¾“å‡ºæ—¶ï¼Œä¼šè°ƒç”¨`StrOperand()`å¯¹`output_str`è¿›è¡Œå¡«å……å¹¶ä½œä¸ºè¯¥operandè¾“å‡ºå­—ç¬¦ä¸²ã€‚æ“ä½œæ•°å¯¹è±¡ç”±ä¸€ç³»åˆ—å‡½æ•° `ir-gen.c:MakeXXXOperand()` æ„é€ ã€‚

```c
struct Operand {
    enum {  VALUE_VAR, ... } kind;
    union {
        char   *var_name;
		...
    } u;
    char *output_str;
};
```

ä¸ºäº†æ–¹ä¾¿è°ƒè¯•ï¼Œåœ¨å®ç°ä¸­ä½¿ç”¨äº†ä¸­é—´ä»£ç è¡¨æ¥å­˜å‚¨åˆ›å»ºå¥½çš„ä¸­é—´ä»£ç å¯¹è±¡ï¼Œè€Œä¸æ˜¯ä¸€åˆ›å»ºå°±ç«‹åˆ»è¾“å‡ºã€‚

ä¸­é—´ä»£ç è¡¨ï¼ˆIC Tableï¼‰è´Ÿè´£è®°å½•å½“å‰ICæ•°é‡ï¼Œä½¿ç”¨åŒå‘é“¾è¡¨å½¢å¼å­˜å‚¨ICï¼Œå¹¶ä¸”æ‹¥æœ‰ä¸¤ä¸ªpointerï¼š`head`å’Œ`tail`ï¼Œæ¯æ¬¡åŠ å…¥ICæ—¶ä¼šä»tailåŠ å…¥ï¼Œè€Œéœ€è¦è¿›è¡Œéå†æ—¶ä»headéå†ã€‚

```c
struct InterCodeNode { 
    struct InterCode        *code; 
    struct InterCodeNode    *prev, *next; 
};
struct InterCodeTable {
    int ic_num;
    struct InterCodeNode *head, *tail;
} intercode_table;
```

æ¯ä¸ªä¸­é—´ä»£ç å¯¹è±¡åˆ›å»ºåï¼Œéƒ½éœ€è¦ä½¿ç”¨å‡½æ•° `ir-gen.c:InsertInterCode()` åŠ å…¥åˆ°ä¸­é—´ä»£ç è¡¨ `intercode_table` ä¸­ã€‚**æ³¨æ„ï¼Œåœ¨å®ç°ä¸­å¹¶ä¸ä¼šå°†ä¸­é—´ä»£ç è¿æˆä»£ç å—åå†åŠ å…¥åˆ°ä»£ç è¡¨ä¸­ï¼Œè€Œæ˜¯åœ¨æ¯æ¡ICåˆ›å»ºå¥½åï¼Œç›´æ¥åŠ å…¥åˆ°ä»£ç è¡¨ã€‚æ‰€ä»¥åœ¨SDTä¸­ï¼Œè¦æ³¨æ„è¿™ä¸€è¡Œä¸ºã€‚**

#### 3.2 ä¸­é—´ä»£ç è¾“å‡º

å®Œæˆä¸­é—´ä»£ç ç”Ÿæˆåï¼Œéœ€è¦ä½¿ç”¨ `PrintInterCodeTable()` éå† IC Table è¿›è¡Œè¾“å‡ºï¼Œ`PrintInterCodeTable`ä¼šè°ƒç”¨ `PrintInterCode()`ï¼Œä¸€ä¸ªæ ¹æ®`InterCode.kind`è¿›è¡Œè¾“å‡ºçš„å‡½æ•°ã€‚

```c
void PrintInterCode(struct InterCode *ic) {
    if(ic->kind == DEC_FUNC) {
        fprintf(OUTPUT_FILENO, "FUNCTION %s :\n",   
                StrOperand(ic->u.dec_func));
        return;
    }
	...
}
```

#### 3.3 å¼•ç”¨è°ƒç”¨

> è‹¥æ•°ç»„æˆ–ç»“æ„ä½“ä½œä¸ºå‚æ•°ä¼ é€’ï¼Œéœ€è°¨è®°æ•°ç»„å’Œç»“æ„ä½“éƒ½è¦æ±‚é‡‡ç”¨**å¼•ç”¨è°ƒç”¨ï¼ˆCall by Referenceï¼‰**çš„å‚æ•°ä¼ é€’æ–¹å¼ï¼Œè€Œéæ™®é€šå˜é‡çš„**å€¼è°ƒç”¨ï¼ˆCall by Valueï¼‰**ã€‚

è¿™ä¸ªå®šä¹‰æ„å‘³ç€ä»€ä¹ˆï¼Ÿæˆ‘ä»¬ä¸ºäº†ç®€å•ï¼Œå…ˆä½¿ç”¨ä¸€ç»´æ•°ç»„æ¥è®²è§£ã€‚

**å¯¹äºä¸€ä¸ªIDè¡¨ç¤ºçš„å˜é‡ï¼Œå³ä½¿å®ƒåœ¨å®šä¹‰æ—¶æ˜¯ä¸€ä¸ªæ•°ç»„ç±»å‹å˜é‡ï¼Œä½†å®ƒä¼šå› ä¸ºå…¶å®šä¹‰çš„ä½ç½®ï¼ˆå‡½æ•°å‚æ•°PARAM or å±€éƒ¨å˜é‡DECï¼‰è€Œè¡¨ç°å‡ºä¸åŒçš„è¡Œä¸ºã€‚**

å¦‚æœè¯¥å˜é‡`a`ä¸ºä¸€ä¸ªPARAMæ•°ç»„ï¼Œé‚£ä¹ˆ `a` æœ¬èº«å°±åº”è¯¥æ˜¯ä¸€ä¸ªåœ°å€å€¼ï¼Œåœ¨å–åŸºå€æ—¶ä½¿ç”¨æ—¶**æ— éœ€**åœ¨å˜é‡IDå‰æ·»åŠ å–å€ç¬¦ &ã€‚

å¦‚æœè¯¥å˜é‡`a`ä¸ºä¸€ä¸ªDECæ•°ç»„ï¼Œé‚£ä¹ˆ `a` æœ¬èº«æ˜¯ä¸€ä¸ªIDï¼Œåœ¨å–åŸºå€æ—¶**éœ€è¦**åœ¨å˜é‡IDå‰æ·»åŠ å–å€ç¬¦ &ã€‚

å…·ä½“ä¸åŒè¡Œä¸ºå¦‚ä¸‹ï¼š

- **ä¼ å‚ç±»å‹ä¸­é—´ä»£ç **ï¼šå‡½æ•°å‚æ•°ä¸ºæ•°ç»„ç±»å‹ï¼Œé‚£ä¹ˆå¯¹äºå‡†å¤‡ä¼ å…¥çš„æ•°ç»„å˜é‡`a`ï¼Œè‹¥ä¸ºPARAMæ•°ç»„ï¼Œç”ŸæˆIC `ARG a`ï¼›è‹¥ä¸ºDECæ•°ç»„ï¼Œç”ŸæˆIC `ARG &a`ã€‚
- **æ•°ç»„å–å€è®¿é—®**ï¼šåœ¨**å–å€**è¿™ä¸€è¡Œä¸ºä¸­ï¼Œå¯¹äºæ•°ç»„å˜é‡`a`ï¼Œè‹¥ä¸ºPARAMæ•°ç»„ï¼Œç”ŸæˆIC `t = a + offset`ï¼›è‹¥ä¸ºDECæ•°ç»„ï¼Œç”ŸæˆIC `t = &a + offset`ã€‚
- **æ•°ç»„åŸŸèµ‹å€¼**ï¼šï¼ˆåŸŸèµ‹å€¼å…·ä½“å®ç°3.5è®²è¿°ï¼‰åŒç†å‡è®¾ PARAMæ•°ç»„`a`,`b`ï¼ŒDECæ•°ç»„`c`,`d`ï¼Œæ¯”è¾ƒä¸€ä¸‹å››è€…ï¼š`a = &c` `a = b` `&c = &d` `&c = b`

å¯¹äºé«˜ç»´æ•°ç»„å’Œç»“æ„ä½“å˜é‡åŒç†ã€‚ï¼ˆç”±äºå®éªŒä¸‰ä¸­ä¿è¯å‡½æ•°æ•°ç»„ç±»å‹å‚æ•°ä¸ºä¸€ç»´æ•°ç»„ï¼Œæ‰€ä»¥å¯ä»¥çœå»ä¸€äº›ä»£ç å®ç°ï¼‰

#### 3.4 åŸŸèµ‹å€¼

å¯¹äºä¸¤ä¸ª**æ•°ç»„ç±»å‹**å˜é‡äºŒå…ƒèµ‹å€¼æ“ä½œï¼Œå¦‚`c = a `æˆ–æ˜¯`d[3] = b[5][7]`è¯¥æ€ä¹ˆåŠï¼Ÿ

åœ¨å®éªŒäºŒä¸­æˆ‘ä»¬æ³¨æ„åˆ°æœ‰ä»¥ä¸‹å®šä¹‰ï¼š

> ä¸€æ˜¯å…³äºæ•°ç»„ç±»å‹çš„ç­‰ä»·æœºåˆ¶ï¼ŒåŒCè¯­è¨€ä¸€æ ·ï¼Œåªè¦æ•°ç»„çš„åŸºç±»å‹å’Œç»´æ•°ç›¸åŒæˆ‘ä»¬å³è®¤ä¸ºç±»å‹æ˜¯åŒ¹é…çš„ï¼Œä¾‹å¦‚`int a[10][2]`å’Œ`int b[5][3]`å±äºåŒä¸€ç±»å‹ï¼›
>
> äºŒæ˜¯æˆ‘ä»¬å…è®¸ç±»å‹ç­‰ä»·çš„ç»“æ„ä½“å˜é‡ä¹‹é—´çš„ç›´æ¥èµ‹å€¼ï¼ˆè§åé¢çš„æµ‹è¯•æ ·ä¾‹ï¼‰ï¼Œè¿™æ—¶çš„è¯­ä¹‰æ˜¯ï¼Œå¯¹åº”çš„åŸŸç›¸åº”èµ‹å€¼ï¼ˆ**æ•°ç»„åŸŸä¹Ÿå¦‚æ­¤ï¼ŒæŒ‰ç›¸å¯¹åœ°å€èµ‹å€¼ç›´è‡³æ‰€æœ‰æ•°ç»„å…ƒç´ èµ‹å€¼å®Œæ¯•æˆ–ç›®æ ‡æ•°ç»„åŸŸå·²ç»å¡«æ»¡**ï¼‰ï¼›

æ‰€ä»¥æ ¹æ®ç¬¬äºŒç‚¹å¯ä»¥å¾—åˆ°è¿™ç±»èµ‹å€¼æ“ä½œçš„å®šä¹‰ï¼šæ•°ç»„åŸŸèµ‹å€¼ã€‚è§£å†³è¿™ä¸ªé—®é¢˜çš„æ–¹æ¡ˆå°±æ˜¯ä¸ºåŒæ–¹å¯¹åº”çš„æ•°ç»„åœ°å€ä¸€ä¸€åˆ›å»ºèµ‹å€¼ç±»å‹çš„ä¸­é—´ä»£ç ï¼š

```c
// ir-gen.c: translate_Exp()
for(int i = 0; i < stuff_size; i++) {
    struct Operand *ta1 = MakeTempOperand();
    struct Operand *ta2 = MakeTempOperand();
    InsertInterCode(Construct_BinOpCode(OP_ADD, ta1, left_addr,  MakeConOperand(i * 4)));
    InsertInterCode(Construct_BinOpCode(OP_ADD, ta2, right_addr, MakeConOperand(i * 4)));
    InsertInterCode(
        Construct_AssignCode(   MakeEvalVarOperand(ta1),
                                MakeEvalVarOperand(ta2))
    );
} 
```

#### 3.5 IR SDT

è¦æ³¨æ„çš„ä¸€ä¸ªåœ°æ–¹æ˜¯å¼•ç”¨è°ƒç”¨å’ŒåŸŸèµ‹å€¼.

è¯¦ç»†è§æ–‡ä»¶ `cmm-IR-SDT.txt`ã€‚

------

## ç¼–è¯‘æ–¹å¼

æœ¬åœ°ä½¿ç”¨GNU Makeè¿›è¡Œç¼–è¯‘ï¼Œç‰ˆæœ¬ä¸º *GNU Make 4.2.1*ã€‚

- ç›´æ¥è¾“å…¥`make`å³å¯ä»¥å¾—åˆ°åˆ†æå™¨æ–‡ä»¶`./parser`ï¼›

- è¾“å…¥`make clean`æ¥æ¸…é™¤ç›®å½•ä¸‹çš„ç”Ÿæˆæ–‡ä»¶ï¼›

- è®¾ç½®DEBUG=YESæ¥è¿›å…¥**debugæ¨¡å¼**ï¼Œè¿™ä¼šåœ¨ç¼–è¯‘è¿‡ç¨‹æ·»åŠ å¯¹åº”å‚æ•°å¹¶è¿›è¡Œæ¡ä»¶ç¼–è¯‘ï¼Œä½¿`./parser`åœ¨åˆ†æè¿‡ç¨‹ä¸­è¿›è¡Œè‡ªåŠ¨æœºè¾“å‡ºï¼›

  > åœ¨è¿›è¡Œè¿™ä¸€æ­¥å‰å¿…é¡»å…ˆ `make clean`

- è®¾ç½®SANITIZE=YESæ¥æ£€æŸ¥è¿è¡Œè¿‡ç¨‹ä¸­æ˜¯å¦å­˜åœ¨**memory leak**ï¼›

- ä½¿ç”¨`make test`æ¥è¿›è¡Œ**è‡ªåŠ¨åŒ–æµ‹è¯•**ï¼Œæµ‹è¯•è¾“å…¥ä¸ºå¯¹`testcase/`ä¸­çš„`.cmm`æ–‡ä»¶ï¼›

- ä½¿ç”¨`make gdb`é…åˆè‡ªå·±ç¼–å†™çš„`init.gdb`æ–‡ä»¶ï¼Œå¯¹æ·»åŠ äº†`-g3`ç¼–è¯‘çš„parserè¿›è¡Œ**è°ƒè¯•**ï¼›æ³¨æ„ï¼Œé¡¹ç›®ä¸­å†™äº†ä¸€ä¸ªå°çš„pythonè„šæœ¬é…åˆgdbå®Œæˆæ–­ç‚¹ç§»åŠ¨çš„åŠŸèƒ½ï¼Œè¯¦ç»†è§`gdb_move.py`ã€‚

æœ¬åœ°Makefileæ–°å¢éƒ¨åˆ†å¦‚ä¸‹ï¼š

```makefile
CC = gcc
FLEX = flex
BISON = bison
CFLAGS = -std=c99 -g3
L_FLAG = 
B_FLAG = -d -v 
DEBUG :=
SANITIZE := 
# â†“â€”â€”â€”â€”â€”â€”â€”â€”åªåœ¨æœ¬åœ°æœ‰æ•ˆâ€”â€”â€”â€”â€”â€”â€”â€”â†“
ifeq ($(DEBUG), YES)
    CFLAGS += -DD_MOD # æ¡ä»¶ç¼–è¯‘ï¼Œç”¨æ¥åœ¨main.cä¸­è®¾ç½®yydebug=1ï¼Œ
	L_FLAG += -d
	B_FLAG += -t
endif
ifeq ($(SANITIZE), YES)
	LEAK_CK := -fsanitize=address
endif
# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

# ç¼–è¯‘ç›®æ ‡ï¼šsrcç›®å½•ä¸‹çš„æ‰€æœ‰.cæ–‡ä»¶
# CFILES = ...åŒOJ Makefile

T_FILES = $(shell find ./testcase -name "*.cmm")
test: $(T_FILES)
	@for file in $^; do \
        echo ">> Parsing $$file ----------------------------------ğŸ‘‡"; \
        ./parser "$$file"; \
		echo ""; \
	done
gdb:
	@gdb -x init.gdb
clean:
# ...åŒOJ Makefile
```

## æ–‡æ¡£é“¾æ¥

- **Flex**ï¼š [Lexical Analysis With Flex, for Flex 2.6.3: Top (virginia.edu)](https://www.cs.virginia.edu/~cr4bd/flex-manual/index.html#SEC_Contents)
- **Bison**ï¼š[Top (Bison 3.8.1) (gnu.org)](https://www.gnu.org/software/bison/manual/html_node/)
- **GDB with Python**ï¼š[Extending GDB using Python](https://sourceware.org/gdb/current/onlinedocs/gdb.html/Python.html#Python)

stage1è¿‡ç¨‹é‡åˆ°çš„ä¸€äº›é—®é¢˜ä»¥åŠå‚è€ƒçš„ä¸€äº›æ–‡ç« ï¼š

- [c++ - When is %destructor invoked in BISON? - Stack Overflow](https://stackoverflow.com/questions/6401286/when-is-destructor-invoked-in-bison)
- [c - How to free memory in bison? - Stack Overflow](https://stackoverflow.com/questions/46729811/how-to-free-memory-in-bison)
- bisonçš„è‡ªæˆ‘å†…å­˜ç®¡ç†ï¼ˆæ ˆåŒºï¼‰ï¼š[Memory Management (Bison 3.8.1) (gnu.org)](https://www.gnu.org/software/bison/manual/html_node/Memory-Management.html)

